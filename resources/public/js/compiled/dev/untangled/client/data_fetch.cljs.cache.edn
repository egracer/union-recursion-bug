;; Analyzed by ClojureScript 1.8.51
{:use-macros {tr untangled.i18n}, :excludes #{}, :name untangled.client.data-fetch, :imports nil, :requires {clojure.walk clojure.walk, om om.next, om.next om.next, impl untangled.client.impl.data-fetch, untangled.client.impl.data-fetch untangled.client.impl.data-fetch, untangled.i18n untangled.i18n, dom om.dom, om.dom om.dom}, :uses {walk clojure.walk, prewalk clojure.walk}, :defs {failed? {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 137, :column 7, :end-line 137, :end-column 14, :arglists (quote ([state]))}, :name untangled.client.data-fetch/failed?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 14, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 137, :end-line 137, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, data-state? {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 134, :column 7, :end-line 134, :end-column 18, :arglists (quote ([state]))}, :name untangled.client.data-fetch/data-state?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 134, :end-line 134, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, ready? {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 135, :column 7, :end-line 135, :end-column 13, :arglists (quote ([state]))}, :name untangled.client.data-fetch/ready?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 13, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 135, :end-line 135, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, loading? {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 136, :column 7, :end-line 136, :end-column 15, :arglists (quote ([state]))}, :name untangled.client.data-fetch/loading?, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 15, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 136, :end-line 136, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, load-field-action {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 72, :column 7, :end-line 72, :end-column 24, :arglists (quote ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}])), :doc "Queue up a remote load of a component's field from within an already-running mutation. Similar to `load-field`\n  but usable from within a mutation. Note the `:refresh` parameter is supported, and defaults to nothing, even for\n  fields, in actions. If you want anything to refresh other than the targeted component you will want to use the\n  :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-field-action ...)\n       ; other optimistic updates/state changes)}", :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(app-state component-class ident field {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]})], :arglists ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-field-action, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 4, :method-params [(app-state component-class ident field {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]})], :arglists ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}]), :arglists-meta (nil)}, :method-params [(app-state component-class ident field {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 72, :end-line 72, :max-fixed-arity 4, :fn-var true, :arglists ([app-state component-class ident field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}]), :doc "Queue up a remote load of a component's field from within an already-running mutation. Similar to `load-field`\n  but usable from within a mutation. Note the `:refresh` parameter is supported, and defaults to nothing, even for\n  fields, in actions. If you want anything to refresh other than the targeted component you will want to use the\n  :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-field-action ...)\n       ; other optimistic updates/state changes)}"}, lazily-loaded {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 141, :column 7, :end-line 141, :end-column 20, :arglists (quote ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x4c0e9dc9 "cljs.tagged_literals.JSValue@4c0e9dc9"] "Loading...")), ready-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x310ff368 "cljs.tagged_literals.JSValue@310ff368"] nil)), failed-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x39ae44bc "cljs.tagged_literals.JSValue@39ae44bc"] nil))}}])), :doc "Custom rendering for use while data is being lazily loaded using the data fetch methods\n  load-collection and load-field.\n\n  `data-render` : the render method to call once the data has been successfully loaded from\n  the server. Can be an Om factory method or a React rendering function.\n\n  `props` : the React properties for the element to be loaded.\n\n  Optional:\n\n  `ready-render` : the render method to call when the desired data has been marked as ready\n  to load, but the server request has not yet been sent.\n\n  `loading-render` : render method once the server request has been sent, and UI is waiting\n  on the response\n\n  `failed-render` : render method when the server returns a failure state for the requested data\n  ALPHA WARNING: The transfer of read errors to failed data states is not implemented in this alpha version.\n\n  `not-present-render` : called when props is nil (helpful for differentiating between a nil and\n  empty response from the server).\n\n  Example Usage:\n\n  ```\n  (defui Thing\n    static om/IQuery\n    (query [this] [{:thing2 (om/get-query Thing2)}])\n    Object\n    (componentDidMount [this]\n       (load-field this :thing2))\n\n    (render [this]\n      (let [thing2 (:thing2 (om/props this))]\n        (lazily-loaded Thing2 thing2))))\n\n  (defui Thing2\n    static om/IQuery\n    (query [this] [:ui/fetch-state])\n    Object\n    (render [this]\n      (display-thing-2))\n  ```", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(data-render props {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x4c0e9dc9 "cljs.tagged_literals.JSValue@4c0e9dc9"] "Loading...")), ready-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x310ff368 "cljs.tagged_literals.JSValue@310ff368"] nil)), failed-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x39ae44bc "cljs.tagged_literals.JSValue@39ae44bc"] nil))}})], :arglists ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x4c0e9dc9 "cljs.tagged_literals.JSValue@4c0e9dc9"] "Loading...")), ready-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x310ff368 "cljs.tagged_literals.JSValue@310ff368"] nil)), failed-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x39ae44bc "cljs.tagged_literals.JSValue@39ae44bc"] nil))}}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/lazily-loaded, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(data-render props {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x4c0e9dc9 "cljs.tagged_literals.JSValue@4c0e9dc9"] "Loading...")), ready-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x310ff368 "cljs.tagged_literals.JSValue@310ff368"] nil)), failed-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x39ae44bc "cljs.tagged_literals.JSValue@39ae44bc"] nil))}})], :arglists ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x4c0e9dc9 "cljs.tagged_literals.JSValue@4c0e9dc9"] "Loading...")), ready-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x310ff368 "cljs.tagged_literals.JSValue@310ff368"] nil)), failed-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x39ae44bc "cljs.tagged_literals.JSValue@39ae44bc"] nil))}}]), :arglists-meta (nil)}, :method-params [(data-render props {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x4c0e9dc9 "cljs.tagged_literals.JSValue@4c0e9dc9"] "Loading...")), ready-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x310ff368 "cljs.tagged_literals.JSValue@310ff368"] nil)), failed-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x39ae44bc "cljs.tagged_literals.JSValue@39ae44bc"] nil))}})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 141, :end-line 141, :max-fixed-arity 2, :fn-var true, :arglists ([data-render props & {:keys [ready-render loading-render failed-render not-present-render], :or {loading-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x4c0e9dc9 "cljs.tagged_literals.JSValue@4c0e9dc9"] "Loading...")), ready-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x310ff368 "cljs.tagged_literals.JSValue@310ff368"] nil)), failed-render (fn [_] (dom/div #object[cljs.tagged_literals.JSValue 0x39ae44bc "cljs.tagged_literals.JSValue@39ae44bc"] nil))}}]), :doc "Custom rendering for use while data is being lazily loaded using the data fetch methods\n  load-collection and load-field.\n\n  `data-render` : the render method to call once the data has been successfully loaded from\n  the server. Can be an Om factory method or a React rendering function.\n\n  `props` : the React properties for the element to be loaded.\n\n  Optional:\n\n  `ready-render` : the render method to call when the desired data has been marked as ready\n  to load, but the server request has not yet been sent.\n\n  `loading-render` : render method once the server request has been sent, and UI is waiting\n  on the response\n\n  `failed-render` : render method when the server returns a failure state for the requested data\n  ALPHA WARNING: The transfer of read errors to failed data states is not implemented in this alpha version.\n\n  `not-present-render` : called when props is nil (helpful for differentiating between a nil and\n  empty response from the server).\n\n  Example Usage:\n\n  ```\n  (defui Thing\n    static om/IQuery\n    (query [this] [{:thing2 (om/get-query Thing2)}])\n    Object\n    (componentDidMount [this]\n       (load-field this :thing2))\n\n    (render [this]\n      (let [thing2 (:thing2 (om/props this))]\n        (lazily-loaded Thing2 thing2))))\n\n  (defui Thing2\n    static om/IQuery\n    (query [this] [:ui/fetch-state])\n    Object\n    (render [this]\n      (display-thing-2))\n  ```"}, load-field {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 9, :column 7, :end-line 9, :end-column 17, :arglists (quote ([component field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}])), :doc "Load a field of the current component. Runs `om/transact!`.\n\n  Parameters\n  - `component`: The component\n  - `field`: A field on the current component's query that you wish to load\n  - `without`: Named parameter for excluding child keys from the query (e.g. for recursive queries or additional laziness)\n  - `params`: Named parameter for adding params to the query sent to the server for this field.\n  - `post-mutation`: A mutation (symbol) invoked after the load succeeds.\n  - `parallel`: Boolean to indicate that this load should happen in the parallel on the server (non-blocking load). Any loads marked this way will happen in parallel.\n  - `fallback`: A mutation (symbol) invoked after the load fails. App state is in env, server error in the params under :error.\n  - `refresh`: A vector of keywords indicating data that will be changing. If any of the listed keywords are queried by on-screen\n    components, then those components will be re-rendered after the load has finished and post mutations have run. Note\n    that for load-field the ident of the target component is automatically included, so this parametmer is usually not\n    needed. If the *special* key `:untangled/force-root` is used in the vector (it must always be a vector), then the entire\n    app will be re-rendered. This is discouraged since it is highly inefficient and should be easily avoidable. It is mainly included\n    in case some re-render bug in Om or Untangled pops up and needs a temporary workaround.\n\n  NOTE: The :ui/loading-data attribute is always included in refresh. This means you probably don't want to\n  query for that attribute near the root of your UI. Instead, create some leaf component with an ident that queries for :ui/loading-data\n  using an Om link (e.g. `[:ui/loading-data '_]`). The presence of the ident on components will enable query optimization, which can\n  improve your frame rate because Om will not have to run a full root query.\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(component field {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]})], :arglists ([component field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-field, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(component field {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]})], :arglists ([component field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}]), :arglists-meta (nil)}, :method-params [(component field {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9, :end-line 9, :max-fixed-arity 2, :fn-var true, :arglists ([component field & {:keys [without params post-mutation fallback parallel refresh], :or [refresh []]}]), :doc "Load a field of the current component. Runs `om/transact!`.\n\n  Parameters\n  - `component`: The component\n  - `field`: A field on the current component's query that you wish to load\n  - `without`: Named parameter for excluding child keys from the query (e.g. for recursive queries or additional laziness)\n  - `params`: Named parameter for adding params to the query sent to the server for this field.\n  - `post-mutation`: A mutation (symbol) invoked after the load succeeds.\n  - `parallel`: Boolean to indicate that this load should happen in the parallel on the server (non-blocking load). Any loads marked this way will happen in parallel.\n  - `fallback`: A mutation (symbol) invoked after the load fails. App state is in env, server error in the params under :error.\n  - `refresh`: A vector of keywords indicating data that will be changing. If any of the listed keywords are queried by on-screen\n    components, then those components will be re-rendered after the load has finished and post mutations have run. Note\n    that for load-field the ident of the target component is automatically included, so this parametmer is usually not\n    needed. If the *special* key `:untangled/force-root` is used in the vector (it must always be a vector), then the entire\n    app will be re-rendered. This is discouraged since it is highly inefficient and should be easily avoidable. It is mainly included\n    in case some re-render bug in Om or Untangled pops up and needs a temporary workaround.\n\n  NOTE: The :ui/loading-data attribute is always included in refresh. This means you probably don't want to\n  query for that attribute near the root of your UI. Instead, create some leaf component with an ident that queries for :ui/loading-data\n  using an Om link (e.g. `[:ui/loading-data '_]`). The presence of the ident on components will enable query optimization, which can\n  improve your frame rate because Om will not have to run a full root query.\n  "}, load-data-action {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 98, :column 7, :end-line 98, :end-column 23, :arglists (quote ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh]}])), :doc "Queue up a remote load from within an already-running mutation. Similar to `load-data`, but usable from\n  within a mutation.\n\n  Note the `:refresh` parameter is supported, and defaults to empty. If you want anything to refresh other than\n  the targeted component you will want to include the :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-data-action ...)\n       ; other optimistic updates/state changes)}", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(app-state query {:keys [ident without params post-mutation fallback parallel refresh]})], :arglists ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh]}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-data-action, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 23, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(app-state query {:keys [ident without params post-mutation fallback parallel refresh]})], :arglists ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh]}]), :arglists-meta (nil)}, :method-params [(app-state query {:keys [ident without params post-mutation fallback parallel refresh]})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 2, :fn-var true, :arglists ([app-state query & {:keys [ident without params post-mutation fallback parallel refresh]}]), :doc "Queue up a remote load from within an already-running mutation. Similar to `load-data`, but usable from\n  within a mutation.\n\n  Note the `:refresh` parameter is supported, and defaults to empty. If you want anything to refresh other than\n  the targeted component you will want to include the :refresh parameter.\n\n  To use this function make sure your mutation specifies a return value with a remote. The remote\n  should use the helper function `remote-load` as it's value:\n\n  { :remote (df/remote-load env)\n    :action (fn []\n       (load-data-action ...)\n       ; other optimistic updates/state changes)}"}, load-data {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 45, :column 7, :end-line 45, :end-column 16, :arglists (quote ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh], :or {refresh []}}])), :doc "Load data from the remote. Runs `om/transact!`. See also `load-field`.\n\n  Parameters\n  - `comp-or-reconciler`: A component or reconciler (not a class)\n  - `query`: The query for the element(s) attributes. Use defui to generate arbitrary queries so normalization will work.\n  - Named parameter `ident`: An ident, used if loading a singleton and you wish to specify 'which one'.\n  - `post-mutation`: A mutation (symbol) invoked after the load succeeds.\n  - `fallback`: A mutation (symbol) invoked after the load fails. App state is in env, server error is in the params under :error.\n  - `parallel`: Boolean to indicate that this load should happen in the parallel on the server (non-blocking load). Any loads marked this way will happen in parallel.\n  - `refresh`: A vector of keywords indicating data that will be changing. If any of the listed keywords are queried by on-screen\n    components, then those components will be re-rendered after the load has finished and post mutations have run.\n\n  Named parameters `:without` and `:params` are as in `load-field`.\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(comp-or-reconciler query {:keys [ident without params post-mutation fallback parallel refresh], :or {refresh []}})], :arglists ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh], :or {refresh []}}]), :arglists-meta (nil)}}, :name untangled.client.data-fetch/load-data, :variadic true, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(comp-or-reconciler query {:keys [ident without params post-mutation fallback parallel refresh], :or {refresh []}})], :arglists ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh], :or {refresh []}}]), :arglists-meta (nil)}, :method-params [(comp-or-reconciler query {:keys [ident without params post-mutation fallback parallel refresh], :or {refresh []}})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 45, :end-line 45, :max-fixed-arity 2, :fn-var true, :arglists ([comp-or-reconciler query & {:keys [ident without params post-mutation fallback parallel refresh], :or {refresh []}}]), :doc "Load data from the remote. Runs `om/transact!`. See also `load-field`.\n\n  Parameters\n  - `comp-or-reconciler`: A component or reconciler (not a class)\n  - `query`: The query for the element(s) attributes. Use defui to generate arbitrary queries so normalization will work.\n  - Named parameter `ident`: An ident, used if loading a singleton and you wish to specify 'which one'.\n  - `post-mutation`: A mutation (symbol) invoked after the load succeeds.\n  - `fallback`: A mutation (symbol) invoked after the load fails. App state is in env, server error is in the params under :error.\n  - `parallel`: Boolean to indicate that this load should happen in the parallel on the server (non-blocking load). Any loads marked this way will happen in parallel.\n  - `refresh`: A vector of keywords indicating data that will be changing. If any of the listed keywords are queried by on-screen\n    components, then those components will be re-rendered after the load has finished and post mutations have run.\n\n  Named parameters `:without` and `:params` are as in `load-field`.\n  "}, remote-load {:protocol-inline nil, :meta {:file "/Users/Ethan/projects/untangled-cookbook/recipes/union-recursion-bug/resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :line 124, :column 7, :end-line 124, :end-column 18, :arglists (quote ([parsing-env])), :doc "Returns the correct value for the `:remote` side of a mutation that should act as a\n  trigger for remote loads. Must be used in conjunction with running `load-data-action` or\n  `load-data-field` in the `:action` side of the mutation (which queues the exact things to\n  load)."}, :name untangled.client.data-fetch/remote-load, :variadic false, :file "resources/public/js/compiled/dev/untangled/client/data_fetch.cljs", :end-column 18, :method-params ([parsing-env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 124, :end-line 124, :max-fixed-arity 1, :fn-var true, :arglists (quote ([parsing-env])), :doc "Returns the correct value for the `:remote` side of a mutation that should act as a\n  trigger for remote loads. Must be used in conjunction with running `load-data-action` or\n  `load-data-field` in the `:action` side of the mutation (which queues the exact things to\n  load)."}}, :require-macros {om om.next, om.next om.next, untangled.i18n untangled.i18n, dom om.dom, om.dom om.dom}, :cljs.analyzer/constants {:seen #{:key :refresh :else :not-present-render :ui/fetch-state :parallel :fallback :params untangled/load :ast :field :state :post-mutation :without :failed-render :ident :dispatch-key :loading-render :ready-render :ui/loading-data :query}, :order [:without :params :post-mutation :fallback :parallel :refresh untangled/load :field :ident :query :ui/loading-data :state :ast :key :dispatch-key :ready-render :loading-render :failed-render :not-present-render :ui/fetch-state :else]}, :doc nil}